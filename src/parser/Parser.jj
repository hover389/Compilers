/* Bantam Java Compiler and Language Toolset.

   Copyright (C) 2007 by Marc Corliss (corliss@hws.edu) and 
                         E Christopher Lewis (lewis@vmware.com).
   ALL RIGHTS RESERVED.

   The Bantam Java toolset is distributed under the following 
   conditions:

     You may make copies of the toolset for your own use and 
     modify those copies.

     All copies of the toolset must retain the author names and 
     copyright notice.

     You may not sell the toolset or distribute it in 
     conjunction with a commerical product or service without 
     the expressed written consent of the authors.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS 
   OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE 
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
   PARTICULAR PURPOSE. 
*/
options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(Parser)
  package parser;

  import util.ErrorHandler;
  import java.util.Stack;
  import java.util.Iterator;

  /** A class for performing syntactic analysis */
  public class Parser 
  {
      /** Maximum string size allowed */
      public static final int MAX_STRING_SIZE = 5000;

      /** Is debugging enabled? */
      private static boolean debug = false;

      /** Filenames of source files */
      private static String[] filenames = null;

      /** Input streams of source files */
      private static java.io.FileInputStream[] fileReaders = null;

      /** Current file number (index into filenames and fileReaders) */
      private static int fileCnt = 0;

      public Parser(String[] filenames, boolean debug) 
      {
	  // set debugging flag
	  this.debug = debug;
	  
	  // initialize filenames field to parameter filenames
	  // used later for finding the name of the current file
	  this.filenames = filenames;
	  
	  // check that there is at least one specified filename
	  if (filenames.length == 0)
	      throw new RuntimeException(
                     "Must specify at least one filename to scan");
	  // must initialize readers for each file (FileInputStream)
	  fileReaders = new java.io.FileInputStream[filenames.length];
	  for (int i = 0; i < filenames.length; i++) {
	      // try...catch checks if file is found
	      try {
		  // create the ith file reader
		  fileReaders[i] = new java.io.FileInputStream(filenames[i]);
	      }
	      catch(java.io.FileNotFoundException e) {
		  // if file not found then report an error and exit
		  System.err.println(
                       "Error: file '" + filenames[i] + "' not found");
		  System.exit(1);
	      }
	  }

	  if (jj_initialized_once) {
	      System.out.println(
                "ERROR: Second call to constructor of static parser.  You must");
	      System.out.println(
         "       either use ReInit() or set the JavaCC option STATIC to false");
	      System.out.println(
         "       during parser generation.");
	      throw new Error();
	  }
	  jj_initialized_once = true;

	  try { jj_input_stream = 
                         new JavaCharStream(fileReaders[0], null, 1, 1); } 
	  catch(java.io.UnsupportedEncodingException e) { 
	      throw new RuntimeException(e); 
	  }

	  ReInit(fileReaders[0]);
      }

      /** Parse program
        * @return true if the source program is syntactically correct
        * */
      public boolean parse() {
	  // initialize the error handler and class list
	  ErrorHandler errorHandler = new ErrorHandler();

	  // loop over the files
	  for (fileCnt = 0; fileCnt < fileReaders.length; fileCnt++) {
	      try {
		  if (fileCnt > 0) 
		        jj_input_stream.ReInit(fileReaders[fileCnt], 1, 1);

		  Parser.Program();

		  System.out.println( 
                        filenames[fileCnt] + " is syntactically correct.");

	      }
	      catch(ParseException e) {
		  String message = e.toString();
		  int index = message.indexOf(": ");
		  message = message.substring(index+2,message.length());
		  errorHandler.register(errorHandler.PARSE_ERROR, 
                                        filenames[fileCnt], 
					JavaCharStream.getBeginLine(), message);
	      }
	  }
	  errorHandler.checkErrors();

	  return true; 
      }

      /** Get the filename of the file currently being scanned */
      public static String getCurrFilename() {
	  return filenames[fileCnt];
      }

  }
PARSER_END(Parser)

TOKEN_MGR_DECLS :
{
    // Use this for error handling
    private static ErrorHandler errorHandler = new ErrorHandler();
}

/******************************************/
/* copy your lexer rules from A1 below... */
/******************************************/

TOKEN : /* KEYWORDS and SPECIAL SYMBOLS */
{
  < CLASS: "class" >
| <COMMA: ",">
| <BREAK: "break">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <LBRACE: "{">
| <RBRACE: "}">
| <LPAREN: "(">
| <RPAREN: ")">
| <RETURN: "return">
| <CASE: "case">
| <ELSE: "else">
| <EXTENDS: "extends">
| <FINALLY: "finally">
| <FOR: "for">
| <IF: "if">
| <IMPORT: "import">
| <INSTOF: "instanceof">
| <NEW: "new">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRY: "try">
| <WHILE: "while">
| <MULT: "*">
| <ADD: "+">
| <SUB: "-">
| <LESSTHAN: "<">
| <GREATERTHAN: ">">
| <SEMICOLON: ";">
| <ASSIGN: "=">
| <MOD: "%">
| <DIV: "/">
| <NOT: "!">
| <EQUALS: "==">
| <NOTEQUALS: "!=">
| <LESSEQUAL: "<=">
| <GREATEREQUAL: ">=">
| <AND: "&&">
| <OR: "||">
| <INCREMENT: "++">
| <DECREMENT: "--">
| <MEMBERREF: ".">


}

TOKEN : /* CONSTANTS - FIXME: broken, only match "Foo", "Goo", or "Zoo" */
{
  < INT_CONST: (["0"-"9"])+ >
	
|
  < BOOLEAN_CONST: "true"|"false" >
|
  < STRING_CONST: "\""(("\\\"")*(~["\""])+)*"\"" >
   
	}
TOKEN : /* IDs - FIXME: broken, only match "Boo" */
{
  < ID: ["A"-"Z","a"-"z"](["a"-"z","A"-"Z","0"-"9","#","@","$","^","&",":","?","~","`","\'","_"])* >

   
}

<*>
TOKEN : /* EOF */
{
  <EOF> { errorHandler.checkErrors(); }
}

SKIP:
{
	" "
|	"\n"
|	"\t"
|	"\r"
| < "//" (~["\r", "\n"])* >
| < "/*" > : MULTICOMMENT

}

<MULTICOMMENT> SKIP :
{
	<"*/"> : DEFAULT
|  	< ~[]>
}

/******************************************/
/* Add your grammar rules below ...       */
/******************************************/

/* 

Precedence (from highest to lowest)
10  new  ()
9   . (dispatch) [] ++ -- (postfix)[left]
8   - (unary) !     ++ -- (prefix) [right]
7   (casting)                      [right]
6   * / %                          [left]
5   + -                            [left]
4   < <= > >= instanceof           [left]
3   == !=                          [left]
2   &&                             [left]
1   ||                             [left]
0   =                              [right]

*/


void Program() :
{}
{
   Class() MoreClass() <EOF>
}

void MoreClass():
{}
{
	Class() MoreClass()
|	{} /*epsilon*/
}

void Class():
{}
{
	<CLASS> <ID> ClassPrime()
}

void ClassPrime():
{}
{
	<EXTENDS> <ID> <LBRACE> MoreMember() <RBRACE>
|	<LBRACE> MoreMember() <RBRACE>
}

void MoreMember():
{}
{
	Member() MoreMember()
|	{} /*epsilon*/
}

void Member():
{}
{
    LOOKAHEAD(5)
	Method() 
|	Field()
}

void Method():
{}
{
	<ID> MethodPrime()
}
/*
void MethodPrime():
{}
{
    <LBRACKET> <RBRACKET> <ID> <LPAREN> MoreFormal() <RPAREN> <LBRACE> MoreStmt() <RBRACE> 
|   <ID> <LPAREN> MoreFormal() <RPAREN> <LBRACE> MoreStmt() <RBRACE>
}
*/


void MethodPrime():
{}
{
    <LBRACKET> <RBRACKET> <ID> <LPAREN> (Formal() <COMMA>)*   <RPAREN> <LBRACE> (Stmt())* <RBRACE>
    |	<ID> <LPAREN> (Formal() <COMMA> )*  <RPAREN> <LBRACE> (Stmt())* <RBRACE>
}





void MoreFormal():
{}
{
	Formal() MoreFormalPrime()
	    |	{} /*epsilon*/
}

void MoreFormalPrime():
{}
{
	<COMMA> Formal() MoreFormalPrime()
	|	{} /*epsilon*/
}

void Field():
{}
{
	<ID> FieldPrime()

}

void FieldPrime():
{}
{
	<LBRACKET> <RBRACKET> <ID> FieldDoublePrime()
|	<ID> FieldDoublePrime()
}

void FieldDoublePrime():
{}
{
	<ASSIGN> Expr() <SEMICOLON>
|	<SEMICOLON>
}

void Formal():
{}
{
	<ID> FormalPrime()
}

void FormalPrime():
{}
{
	<LBRACKET> <RBRACKET> <ID>
|	<ID>
}

void Stmt():
{}
{
    LOOKAHEAD(2)
	ExprStmt()
|	DeclStmt()
|	IfStmt()
|	WhileStmt()
|	ForStmt()
|	BreakStmt()
|	ReturnStmt()
|	BlockStmt()

}

void ExprStmt():
{}
{
	Expr()
}

void DeclStmt():
{}
{
	<ID> DeclStmtPrime()
}

void DeclStmtPrime():
{}
{
	<LBRACKET> <RBRACKET> DeclStmtDoublePrime()/*<ID> <ASSIGN> Expr() <SEMICOLON>*/
|	DeclStmtDoublePrime()/*<ID> <ASSIGN> Expr() <SEMICOLON>*/
}

void DeclStmtDoublePrime():
{}
{
	<ID> <ASSIGN> Expr() <SEMICOLON>
}

void IfStmt():
{}
{
	<IF> <LPAREN> Expr() <RPAREN> IfStmtPrime() 
}

void IfStmtPrime():
{}
{
    
     	<ELSE> Stmt()
|       {}
}

void WhileStmt():
{}
{
	<WHILE> <LPAREN> Expr() <RPAREN> Stmt()
}

void ForStmt():
{}
{
	<FOR> <LPAREN> ForStmtPrime()
}

void ForStmtPrime():
{}
{
	Expr() <SEMICOLON> ForStmtDoublePrime()
|	<SEMICOLON> ForStmtQuadPrime()
}

void ForStmtDoublePrime():
{}
{
	<SEMICOLON> ForStmtTriplePrime()
|	Expr() <SEMICOLON> ForStmtTriplePrime()
}

void ForStmtTriplePrime():
{}
{
	Expr() <RPAREN> Stmt()
|	<RPAREN> Stmt()
}

void ForStmtQuadPrime():
{}
{
	<SEMICOLON> ForStmtTriplePrime()
|	Expr() <SEMICOLON> ForStmtTriplePrime()
}


void BreakStmt():
{}
{
	<BREAK> <SEMICOLON>
}

void ReturnStmt():
{}
{
	<RETURN> ReturnStmtPrime()
}

void ReturnStmtPrime():
{}
{
	Expr() <SEMICOLON>
|	<SEMICOLON>
}

void BlockStmt():
{}
{
    <LBRACE> (Stmt())* <RBRACE>
}

/*
void MoreStmt():
{}
{
    Stmt() MoreStmt() | {}
}
*/

void Expr():
{}
{
    LOOKAHEAD(3)
    AssignExpr() ExprPrime()
	|	LOOKAHEAD(2) DispatchExpr() ExprPrime()
	|	LOOKAHEAD(2) NewExpr() ExprPrime()
	|	LOOKAHEAD(3)CastExpr() ExprPrime()
	//|	BinaryExpr() ExprPrime()
|	UnaryExpr() ExprPrime() 
|	ConstExpr() ExprPrime() 
|	VarExpr() ExprPrime()
|	<LPAREN> Expr() <RPAREN> ExprPrime()
	|       <INCREMENT> Expr() ExprPrime()
	|      <DECREMENT> Expr() ExprPrime()
	
}

void ExprDoublePrime():
{}
{
    LOOKAHEAD(3)
    AssignExpr() ExprPrime()
	|	LOOKAHEAD(3) DispatchExpr() ExprPrime()
|	NewExpr() ExprPrime()
	|	LOOKAHEAD(3)CastExpr() ExprPrime()
	//|	BinaryExpr() ExprPrime()
|	UnaryExpr() ExprPrime() 
|	ConstExpr() ExprPrime() 
|	VarExpr() ExprPrime()
|	<LPAREN> Expr() <RPAREN> ExprPrime()
	|       <INCREMENT> Expr() ExprPrime()
	|      <DECREMENT> Expr() ExprPrime()
	| <MEMBERREF> <ID> <LPAREN> MoreExpr() <RPAREN> ExprDoublePrime() 
	|{}
	
}

void ExprPrime():
{}
{
    LOOKAHEAD(3)
    <INSTOF> <ID> ExprPrime() 
|   <INSTOF> <ID> <LBRACKET> <RBRACKET> ExprPrime()
|   <ADD> Expr() ExprPrime() 
|   <SUB> Expr() ExprPrime()
|   <MULT> Expr() ExprPrime()
|   <DIV>  Expr() ExprPrime()
|   <MOD> Expr() ExprPrime()
|   <EQUALS> Expr() ExprPrime()
|   <NOTEQUALS>  Expr() ExprPrime()
|   <LESSTHAN>  Expr() ExprPrime()
|   <LESSEQUAL>  Expr() ExprPrime()
|   <GREATERTHAN>  Expr() ExprPrime()
|   <GREATEREQUAL>  Expr() ExprPrime()
|    <AND> Expr() ExprPrime()
|   <OR> Expr() ExprPrime()
|   <INCREMENT> | <DECREMENT>
	|   {}
}

void AssignExpr():
{}
{
	VarExpr() <ASSIGN> Expr()
}

void DispatchExpr():
{}
{
      /*<ID> <LPAREN> MoreExpr() <RPAREN>*/
	 	DispatchExprPrime() DispatchExprDoublePrime()  /*<ID> <LPAREN> MoreExpr() <RPAREN>*/
}

void DispatchExprDoublePrime():
{}
{
    <MEMBERREF> DispatchExprPrime() DispatchExprDoublePrime()
|   {}
}

void DispatchExprPrime():
{}
{
    <ID> <LPAREN> MoreExpr() <RPAREN> ExprDoublePrime()
	
}


void MoreExpr():
{}
{
	Expr() MoreExprPrime()
|	{} /*epsilon*/
}
void MoreExprPrime():
{}
{
	<COMMA> Expr() MoreExpr()
|	{} /*epsilon*/
}

void NewExpr():
{}
{
    LOOKAHEAD(3)
	<NEW> <ID> <LPAREN> <RPAREN> | <NEW> <ID> <LBRACKET> Expr() <RBRACKET>
}

/*
void InstanceofExpr():
{}
{
     <INSTOF> <ID> InstanceofExprPrime() InstanceofExpr()
|   {}
}

void InstanceofExprPrime():
{}
{
	<LBRACKET> <RBRACKET>
|	{}
}
*/
void CastExpr():
{}
{
	<LPAREN> <ID> CastExprPrime()
}

void CastExprPrime():
{}
{
	<LBRACKET> <RBRACKET> <RPAREN> <LPAREN> Expr() <RPAREN>
|	<RPAREN> <LPAREN> Expr() <RPAREN>
}
/*
void BinaryExpr():
{}
{
	BinaryArithExpr()  | BinaryCompExpr() | BinaryLogicExpr()
}
*/
void UnaryExpr():
{}
{
    UnaryNegExpr() | UnaryNotExpr() //| UnaryIncrExpr() | UnaryDecrExpr()
}

void ConstExpr():
{}
{
	<INT_CONST> | <BOOLEAN_CONST> | <STRING_CONST>
}
/*
void BinaryArithExpr():
{}
{
    <ADD> Expr() BinaryArithExpr() 
|   <SUB> Expr() BinaryArithExpr()
|   <MULT> Expr() BinaryArithExpr()
|   <DIV>  Expr() BinaryArithExpr()
|   <MOD> Expr() BinaryArithExpr()
|   {}
    
}
/*
/*
void Arith():
{}
{
	<ADD> Expr()
|	<SUB> Expr()
|	{} epsilon
}

void Arith1():
{}
{
	Arith3() Arith2()
}

void Arith2():
{}
{
	<MULT> Arith1()
|	<DIV> Arith1()
|	<MOD> Arith1()
|	{} epsilon
}

void Arith3():
{}
{
    <LPAREN> Expr() <RPAREN> Arith3Prime()
|	Expr()
}

void Arith3Prime():
{}
{
    Arith3Prime()
|   {}
}
*/


/*
void BinaryCompExpr():
{}
{
    <EQUALS> Expr() BinaryCompExpr()
|   <NOTEQUALS>  Expr() BinaryCompExpr()
|   <LESSTHAN>  Expr() BinaryCompExpr()
|   <LESSEQUAL>  Expr() BinaryCompExpr()
|   <GREATERTHAN>  Expr() BinaryCompExpr()
|   <GREATEREQUAL>  Expr() BinaryCompExpr()
|   {}
    
}
*/
/*
void BinaryCompExprPrime():
{}
{
	<AND> Expr()
|	<OR> Expr()
}
*/
//Binary logic might be wrong
/*
void BinaryLogicExpr():
{}
{
    <AND> Expr() BinaryLogicExpr()
|   <OR> Expr() BinaryLogicExpr()
	|    {} 
   
}
*/
/*
void Logic():
{}
{
	<AND> Expr()
|	{} epsilon
}

void Logic1():
{}
{
	Logic3() Logic2()
}

void Logic2():
{}
{
	<OR> Expr()
| 	{} epsilon
}

void Logic3():
{}
{
	Expr()
}
*/
void UnaryNegExpr():
{}
{
	<SUB> Expr()
}

void UnaryNotExpr():
{}
{
	<NOT> Expr()
}
/*
void UnaryIncrExpr():
{}
{
	//fix precedence
    <INCREMENT> Expr() UnaryIncrExprPrime()
}

void UnaryIncrExprPrime():
{}
{
    <INCREMENT> UnaryIncrExprPrime() 
	|   {}
}

void UnaryDecrExpr():
{}
{
	//fix precedence
    <DECREMENT> Expr() UnaryDecrExprPrime()
}

void UnaryDecrExprPrime():
{}
{
    <DECREMENT> UnaryDecrExprPrime()
	|   {}
}
*/
/*void VarExpr():
{}
{
	Expr() <MEMBERREF> <ID> VarExpr'()
|	<MEMBERREF> <ID> VarExpr''()
}

void VarExpr'():
{}
{
	<LBRACKET> Expr() <RBRACKET>
|	{} epsilon
}

void VarExprDoublePrime():
{}
{
	<LBRACKET> Expr() <RBRACKET> 
|	{} epsilon
}*/ 

void VarExpr():
{}
{
       	<ID> VarExprPrime() VarExprPrime() 
	
}

void VarExprPrime():
{}   
{
    <MEMBERREF> <ID> VarExprDoublePrime() VarExprPrime()
    |{}
}

void VarExprDoublePrime():
{}
{
	<LBRACKET> Expr() <RBRACKET>
|	{} /*epsilon*/
}
